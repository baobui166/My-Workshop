[{"uri":"https://baobui166.github.io/My-Workshop/2-preparation/2.1-createdyanmodb/","title":"Create DynamoDB","tags":[],"description":"","content":"Create DynamoDB Table In the API monitoring system, we will use Amazon DynamoDB as a NoSQL database to store information such as user logs, API queries, or other data that needs to be tracked in real time.\nObjective of this step:\nCreate a DynamoDB table to be used during the Lambda deployment process. Configure the primary key and basic settings. Steps to follow:\nLog in to AWS Console: Visit: AWS console Ensure you have selected the correct region (e.g., us-east-1 or ap-southeast-1). Navigate to the DynamoDB service: Search for DynamoDB in the search bar and select the service. Create a new table: Click the \u0026ldquo;Create table\u0026rdquo; button. Enter table details: Table name: WebsiteVisitors (or any custom name)\nPartition key: userKey\nData type: String\n(Optional) You can add a Sort key to organize data by time or endpoint.\nExample: timestamp - Number Create the table: Finally, click \u0026ldquo;Create table\u0026rdquo; to complete the setup. Confirm table creation success: Next, we will create the Lambda Functions.\n"},{"uri":"https://baobui166.github.io/My-Workshop/1-introduce/","title":"Introduction","tags":[],"description":"","content":"Before diving into implementing a full API monitoring solution, it’s important to understand the core concepts of Serverless Monitoring and how AWS observability tools integrate seamlessly within serverless environments.\nServerless Monitoring \u0026amp; Observability While serverless applications eliminate infrastructure management, they introduce new challenges in monitoring, debugging, and ensuring SLA compliance. To address this, AWS offers a comprehensive suite of tools to:\nMonitor performance metrics Trace execution flows Trigger real-time alerts — All without managing servers.\nAWS Services Used In this project, we’ll build an end-to-end API monitoring system using serverless architecture, incorporating the following AWS services:\nCompute: AWS Lambda API Management: Amazon API Gateway Database: Amazon DynamoDB Monitoring \u0026amp; Observability: Amazon CloudWatch Logs for centralized logging CloudWatch Metrics for tracking latency, traffic, and errors CloudWatch Alarms + SNS for real-time alerting AWS X-Ray for distributed tracing and performance analysis Overview of AWS Lambda AWS Lambda lets you run backend logic in response to events without provisioning or managing infrastructure. Benefits include:\nAutomatic scaling and high availability Seamless integration with API Gateway and CloudWatch Event-driven architecture with flexible memory and timeout configuration Hands-on Implementation In this workshop, you’ll be guided through building a full serverless monitoring system, including:\nCreating a Lambda-based API with API Gateway\nIntegrating CloudWatch Logs and Metrics for performance tracking\nSetting up CloudWatch Alarms with SNS to notify on anomalies\nEnabling AWS X-Ray for request tracing and error diagnosis\nVisualizing metrics and logs for continuous monitoring\nWriting basic documentation for monitored APIs\nOutcome: By the end of this workshop, you’ll have a fully observable, alert-driven, serverless API system — powered entirely by native AWS services.\n"},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/3.2.1-cloudwatchlogs/","title":"Monitoring Logs of a Lambda Function","tags":[],"description":"","content":"Monitoring Logs of a Lambda Function Access the Lambda Function Go to the AWS Console Navigate to the Lambda service Select the function you want to view logs for Click on the \u0026ldquo;Monitor\u0026rdquo; tab In the Lambda function interface → click on the Monitor tab Then click on View CloudWatch Logs View Detailed Logs Once you\u0026rsquo;re on the Log events screen, select the latest log stream (based on timestamp) Here, you will see logs like: Analysis: INIT_START: Appears when the Lambda starts for the first time (cold start); shows the runtime version used (e.g., Python 3.11), and the actual runtime ARN. This does not appear on every invocation—only when a new container is created. START: Indicates the Lambda function has begun processing a new request includes: RequestId: A unique ID for each invocation Version: The version of the Lambda function being executed ($LATEST is the default). END: Indicates the Lambda function has finished processing the request, with the same RequestId as START. REPORT: Displays performance metrics: Duration: Actual execution time (e.g., 490.34 ms) Billed Duration: AWS rounds up to the nearest millisecond for billing (491 ms) Memory Size: Configured memory for the function (128 MB) Max Memory Used: Actual memory used during that invocation (e.g., 58 MB) "},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.1-preparation/","title":"Preparation","tags":[],"description":"","content":"Preparation Enabling and configuring logs and tracing in API Gateway (REST API) helps you monitor, debug, and analyze the behavior of your application effectively.\nObjectives: Enable Access Logs to capture detailed request/response data. Enable Execution Logs to trace internal execution steps (for REST APIs). Enable X-Ray Tracing to follow the request flow across AWS services like API Gateway → Lambda → DynamoDB. Steps to configure: 1. Access API Gateway Sign in to AWS Console: https://console.aws.amazon.com/ Search for “API Gateway” and select the service. 2. Select your target API Go to API Gateway → Select your API Click Stages → Choose a stage (e.g., dev, prod) Click Edit in the Logs and Tracing section 3. Enable the following options: Errors and info logs: Capture both errors and detailed request/response info (recommended for debugging). Data tracing: Log full request and response payloads. Detailed metrics: Enable detailed CloudWatch metrics including count, latency, 4XX, and 5XX errors. X-Ray tracing: Activate AWS X-Ray to trace full request flow through services. Next: Use CloudWatch Metrics, Logs Insight, Alarm, Dashboard, and X-Ray to monitor your APIs.\n"},{"uri":"https://baobui166.github.io/My-Workshop/","title":"Session Management","tags":[],"description":"","content":"API performance monitoring and error tracking Overview In an era where modern applications demand rapid responsiveness and flexible scalability, monitoring and tracking API operations play a crucial role in ensuring service quality (SLA), system performance, and early detection of incidents. This workshop is designed to provide a step-by-step guide on how to implement a comprehensive API Monitoring system on the AWS Serverless platform, leveraging core services such as AWS Lambda, API Gateway, and DynamoDB, while integrating monitoring tools like CloudWatch Logs, CloudWatch Metrics, CloudWatch Alarms, SNS, and AWS X-Ray to:\nMonitor the performance of each API endpoint.\nAnalyze detailed errors across different processing layers.\nTrigger real-time alerts when performance thresholds are exceeded or critical errors occur.\nEnsure compliance with predefined SLA metrics.\nAutomate log collection and analysis to optimize operational workflows.\nContent Introduction Preparation Observability Tracing Documentation Clean up resources "},{"uri":"https://baobui166.github.io/My-Workshop/2-preparation/2.2-createlambda/","title":"Create Lambda function","tags":[],"description":"","content":"Create Lambda function In this step, we will create an AWS Lambda Function, fully configuring elements such as: source code, access permissions (IAM Role), environment variables, and testing the function to log data into DynamoDB.\nGoals:\nCreate a Lambda function to handle API logic.. Configure an IAM Role that grants write permissions. Add environment variables to store MongoDB connection info (URI, DB name, collection). Write and directly deploy the handler code. Steps:\nAccess the Lambda Service: Go to AWS Console: AWS console Search for “Lambda” in the search bar and select AWS Lambda service. Create a Lambda function: Click “Create function”.\nChoose on Author from scratch.\nEnter the details:\nFunction name: GetVisitor. Runtime: Python 3.11. Click Create Function. Deploy the source code Paste the following code into the editor. import json import boto3 from datetime import datetime import urllib.request dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;WebsiteVisitors\u0026#39;) def get_location(ip): try: with urllib.request.urlopen(f\u0026#34;http://ip-api.com/json/{ip}\u0026#34;) as url: data = json.loads(url.read().decode()) return { \u0026#39;country\u0026#39;: data.get(\u0026#39;country\u0026#39;), \u0026#39;region\u0026#39;: data.get(\u0026#39;regionName\u0026#39;), \u0026#39;city\u0026#39;: data.get(\u0026#39;city\u0026#39;), \u0026#39;lat\u0026#39;: data.get(\u0026#39;lat\u0026#39;), \u0026#39;lon\u0026#39;: data.get(\u0026#39;lon\u0026#39;), } except: return {} def lambda_handler(event, context): headers = event.get(\u0026#39;headers\u0026#39;, {}) request_context = event.get(\u0026#39;requestContext\u0026#39;, {}) ip = request_context.get(\u0026#39;identity\u0026#39;, {}).get(\u0026#39;sourceIp\u0026#39;, \u0026#39;unknown\u0026#39;) user_agent = headers.get(\u0026#39;User-Agent\u0026#39;, headers.get(\u0026#39;user-agent\u0026#39;, \u0026#39;unknown\u0026#39;)) visit_time = str(datetime.utcnow()) location = get_location(ip) key = f\u0026#34;{ip}_{user_agent}\u0026#34; if ip != \u0026#39;unknown\u0026#39; else \u0026#39;unknown\u0026#39; try: response = table.get_item(Key={\u0026#39;user_key\u0026#39;: key}) item = response.get(\u0026#39;Item\u0026#39;, {}) if item: item[\u0026#39;count\u0026#39;] = int(item.get(\u0026#39;count\u0026#39;, 0)) + 1 item[\u0026#39;last_visit\u0026#39;] = visit_time else: item = { \u0026#39;user_key\u0026#39;: key, \u0026#39;ip\u0026#39;: ip, \u0026#39;user_agent\u0026#39;: user_agent, \u0026#39;count\u0026#39;: 1, \u0026#39;first_visit\u0026#39;: visit_time, \u0026#39;last_visit\u0026#39;: visit_time, \u0026#39;country\u0026#39;: location.get(\u0026#39;country\u0026#39;), \u0026#39;city\u0026#39;: location.get(\u0026#39;city\u0026#39;), \u0026#39;lat\u0026#39;: str(location.get(\u0026#39;lat\u0026#39;)), \u0026#39;lon\u0026#39;: str(location.get(\u0026#39;lon\u0026#39;)) } table.put_item(Item=item) return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;message\u0026#34;: \u0026#34;Visitor tracked successfully\u0026#34;, \u0026#34;user_key\u0026#34;: key, \u0026#34;count\u0026#34;: item[\u0026#39;count\u0026#39;] }) } cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) cloudwatch.put_metric_data( Namespace=\u0026#39;VisitorAnalytics\u0026#39;, MetricData=[ { \u0026#39;MetricName\u0026#39;: \u0026#39;TotalVisits\u0026#39;, \u0026#39;Dimensions\u0026#39;: [{\u0026#39;Name\u0026#39;: \u0026#39;Country\u0026#39;, \u0026#39;Value\u0026#39;: location.get(\u0026#39;country\u0026#39;, \u0026#39;Unknown\u0026#39;)}], \u0026#39;Value\u0026#39;: 1, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39; } ] ) except Exception as e: print(f\u0026#34;Error: {e}\u0026#34;) return { \u0026#34;statusCode\u0026#34;: 500, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;message\u0026#34;: \u0026#34;Error processing request\u0026#34;, \u0026#34;error\u0026#34;: str(e) }) } Then click Deloy. Add Environment Variables Go to Configuration tab, then click Environment variables. Click Edit and click Add eviromment variable Add the following key-value pair:: Key: WebsiteVisitors Value: WebsiteVisitors Click save to completed. Update IAM Role Go to Configuration tab, then chosse Environment variables. Click on Role name. Once on the IAM Role page, click Add permissions, then choose Attach policies. Select the policy named: AmazonDynamoDBFullAccess Then choose Add permission. Now repeat the steps above to create another Lambda function::\nFunction name: createUser. Runtime: Python 3.11. Deploy the following code. import json import uuid from datetime import datetime import boto3 dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;Users\u0026#39;) cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) def put_custom_metric(metric_name): cloudwatch.put_metric_data( Namespace=\u0026#39;YourApp/Lambda\u0026#39;, MetricData=[{ \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: 1, \u0026#39;Unit\u0026#39;: \u0026#39;Count\u0026#39; }] ) def lambda_handler(event, context): print(\u0026#34;Received event:\u0026#34;, json.dumps(event)) try: body = json.loads(event.get(\u0026#39;body\u0026#39;, \u0026#39;{}\u0026#39;)) name = body.get(\u0026#39;name\u0026#39;) email = body.get(\u0026#39;email\u0026#39;) if not name or not email: # Gửi metric cho lỗi Client put_custom_metric(\u0026#39;ClientErrors\u0026#39;) return { \u0026#34;statusCode\u0026#34;: 400, \u0026#34;body\u0026#34;: json.dumps({\u0026#34;message\u0026#34;: \u0026#34;Name and email are required\u0026#34;}) } user = { \u0026#39;user_id\u0026#39;: str(uuid.uuid4()), \u0026#39;name\u0026#39;: name, \u0026#39;email\u0026#39;: email, \u0026#39;created_at\u0026#39;: datetime.utcnow().isoformat() } table.put_item(Item=user) return { \u0026#34;statusCode\u0026#34;: 201, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;message\u0026#34;: \u0026#34;User created successfully\u0026#34;, \u0026#34;user\u0026#34;: user }) } except Exception as e: print(\u0026#34;Error:\u0026#34;, str(e)) # Gửi metric cho lỗi Server put_custom_metric(\u0026#39;ServerErrors\u0026#39;) return { \u0026#34;statusCode\u0026#34;: 500, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;message\u0026#34;: \u0026#34;Internal server error\u0026#34;, \u0026#34;error\u0026#34;: str(e) }) } Repeat the IAM Role configuration step. Next, we will create the API Gateways.\n"},{"uri":"https://baobui166.github.io/My-Workshop/2-preparation/","title":"Preparation","tags":[],"description":"","content":" You need to create a Lambda function, an API Gateway endpoint, and a DynamoDB table to perform this lab.\nTo get started with Serverless services like AWS Lambda, API Gateway, and DynamoDB, this lab will guide you through creating and integrating these components step by step.\nYou can refer to the following AWS documentation for more background:\nWhat is AWS Lambda? What is Amazon API Gateway? What is Amazon DynamoDB? In order for the Lambda function to interact securely with API Gateway and DynamoDB, we also need to create and assign an IAM Role with appropriate permissions. This will ensure our Lambda function can perform operations like reading/writing data from DynamoDB and returning responses through API Gateway.\nContent Create DynamoDB Create Lambda Create API Gateway "},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/3.2.2-cloudwatchmetrics/","title":"Using CloudWatch Metrics to Monitor API Gateway","tags":[],"description":"","content":"Using CloudWatch Metrics to Monitor API Gateway Use CloudWatch Metrics to monitor API Gateway directly from the AWS Console interface.\nObjectives:\nMonitor the number of requests, 4xx and 5xx errors, latency, integration latency, etc., of API Gateway No need to create additional CloudWatch Log Groups or write manual code Steps to follow:\nAccess CloudWatch Log in to the AWS Console Type \u0026ldquo;CloudWatch\u0026rdquo; in the search bar → select CloudWatch Choose Metrics \u0026gt; All Metrics In the left menu, choose Metrics → click All metrics In the Browse section, select Lambda: Select the Metrics to Monitor: Choose By Resource Then select the function name(s) you want to monitor (we will focus on 3 main components: Throttles, Errors, and Duration) Observe them on the chart The 3 displayed metrics are:\nDuration: The average execution time of the Lambda function (in ms) at each point in time. Displayed in green. Errors: The number of errors that occurred at that point. Displayed in orange. Throttles: The number of times the Lambda was throttled (exceeded allowed requests). Displayed in light blue. When you hover over the data point at 07-30 09:35 UTC, CloudWatch shows:\nDuration: 121.79 ms → Lambda took about 122 ms to execute\nErrors: 0.4 → An average error rate (e.g., 2 errors in 5 requests or a rounded value)\nThrottles: 0 → No requests were throttled at that time\n"},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/","title":"Using CloudWatch to Collect and Analyze Data","tags":[],"description":"","content":"During the application monitoring process on AWS, we will use a suite of powerful Amazon CloudWatch tools to collect and analyze operational data. CloudWatch Logs allows you to record logs from services like API Gateway, supporting debugging and error tracing. CloudWatch Metrics helps track performance indicators such as latency, request count, and error rates. Based on these metrics, we can set up Alarms to automatically detect incidents and trigger alerts through Amazon SNS to email or other services. In addition, CloudWatch Log Insights offers a powerful query tool to analyze logs in an intuitive and efficient way. Finally, we will use CloudWatch Dashboards to create visual dashboards that centralize all metrics, logs, and alert charts, making it easier to monitor the overall system activity in real time.\nContents: Analyzing with CloudWatch Logs Monitoring with CloudWatch Metrics Incident Detection and Alerts via Alarm and SNS Querying Errors with Log Insight Querying Logs with CloudWatch Log Insights Creating Dashboards "},{"uri":"https://baobui166.github.io/My-Workshop/2-preparation/2.3-createapigateway/","title":"Create API Gateway","tags":[],"description":"","content":"Create API Gateway In this step, you will create a REST API using Amazon API Gateway, connect it to the Lambda function created in the previous step, and then deploy it to expose a public endpoint.\nObjectives:\nCreate a REST API using API Gateway Integrate the Lambda function as the backend Configure the method and resource path Deploy the API to a public endpoint Steps to follow:\nAccess API Gateway Go to AWS Console: https://console.aws.amazon.com/ Type “API Gateway” in the search bar and select the service. Create a new API: Click the “Create API” button Choose the API type:\nSelect REST API (Build) Click Build In API details, choose New API Enter a name for your API -Example: Visitor Click Create API Click Create Method to add methods to the API Select the GET method Choose the Lambda function you created earlier as the integration target Click Create to finish Deloy API Click Deploy API, then configure as follows: Click Deloy. Test if the API is working Copy the Invoke URL of the newly deployed API Paste it into a new browser tab and press Enter:\nGo to DynamoDB to verify if the API is functioning correctly. If successful, you should see new data added to the database. In the next section, we will begin monitoring and observing our APIs through CloudWatch.\n"},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/3.2.3-cloudwatchalarmsns/","title":"Creating Alarm and SNS","tags":[],"description":"","content":"Creating Alarm and SNS Use Amazon CloudWatch Alarm combined with Amazon SNS to send email notifications whenever your API encounters an error. This is applicable when your API is running on AWS (Lambda, API Gateway, etc.).\nObjectives\nMonitor errors (e.g., 5XX in API Gateway, error count in Lambda). When errors exceed a specified threshold → send email alerts. Steps to implement\nGo to the CloudWatch Console Choose Alarms → Create Alarm Click Select metric\nSelect Lambda → By Resource → choose Error (Metric name)\nSelect By Resource Choose Error (Metric name) Configure the conditions for SNS to work smoothly when an error occurs Create a new SNS topic to use with the Alarm. Enter the email address you want to receive alerts in the Email endpoint field. Click Next, then name your alarm Finally, review the selected configurations and click Create Note: If you want to create an alarm for API Gateway, at the initial Select metric step, choose API Gateway → By Stage → Method → 5XXError.\nThe remaining steps are the same as above.\nEmail Notification Result When the System Encounters an Issue: "},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/","title":"Monitor and Observe APIs with CloudWatch","tags":[],"description":"","content":"Monitor and Observe APIs with CloudWatch In modern serverless architecture, ensuring service quality goes beyond deployment — it heavily relies on observability. Observability allows us to understand what\u0026rsquo;s happening inside the system by collecting, analyzing, and visualizing data related to operations, performance, and failures.\nWhy is monitoring important? Understand system behavior By collecting logs, recording metrics, and querying through CloudWatch Logs Insights, you can:\nMonitor request flow and execution lifecycle Analyze behavior of APIs and Lambda functions Quickly identify the root cause of issues Detect and respond to incidents early Integrate CloudWatch Alarms with Amazon SNS Automatically send email alerts when thresholds are breached Allow fast incident response before affecting end-users Measure performance \u0026amp; optimize Monitor key indicators: latency, invocation count, error rate Improve performance and scale based on data Align with SLA (Service Level Agreement) expectations Advanced log analysis Use Logs Insight for deep log querying and filtering Analyze real-time behavior or historical logs Identify patterns, frequent errors, and optimization opportunities Table of Contents 3.1. Preparation\nSet up resources and enable logging/tracing\n3.2. Monitor APIs using CloudWatch Metrics\nTrack API Gateway \u0026amp; Lambda metrics such as error rate, latency\nBy combining logs, metrics, alarms, dashboards, and insight queries, you can build a robust observability system — empowering you to maintain quality, stability, and visibility even in serverless production environments.\n"},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/3.2.4-cloudwatchloginsight/","title":"Log Insight","tags":[],"description":"","content":"Observing via Log Insight Objectives\nMonitor queries and performance of the entire request flow. Log in a standardized structured format (JSON). Efficiently query logs using CloudWatch Logs Insights to optimize performance. Analyze slow queries, 4xx/5xx errors, DynamoDB throttling, and cost impacts. Steps 1. Go to CloudWatch Console Navigate to CloudWatch → Logs Insights Select a log group: /aws/lambda/my-function or /aws/apigateway/... 2. Sample Logs Insights Queries for Lambda Query Lambda errors (status code 4xx, 5xx): fields @timestamp, @message | filter @message like /ERROR/ | sort @timestamp desc | limit 100 Sample log analysis content:\nError type: [ERROR] ClientError: An error occurred (AccessDenied) when calling the PutMetricData operation. Description: The Lambda function is trying to call CloudWatch’s PutMetricData API to push metrics but was denied access (AccessDenied). Cause: The user or role assigned to the Lambda function lacks permission to call PutMetricData. Location: Lambda function named create_user in the ap-southeast-1 region. Other log info includes: timestamp, account ID, environment, log stream, and traceback from the Python Lambda code. Statistics on Lambda runtime and resource usage (duration, memory):\nfilter @type = \u0026#34;REPORT\u0026#34; | stats avg(@duration) as AverageDuration, max(@duration) as MaxDuration, min(@duration) as MinDuration, avg(@maxMemoryUsed/1024/1024) as AverageMemoryUsedMB, max(@maxMemoryUsed/1024/1024) as MaxMemoryUsedMB, min(@maxMemoryUsed/1024/1024) as MinMemoryUsedMB Explanation:\nAverageDurationMS: Average execution time of the Lambda function within the queried time range (in milliseconds).\nMaxDuration: Maximum execution time during that period.\nMinDuration: Minimum execution time.\nAverageMemoryUsedMB: Average memory used (MB).\nMaxMemoryUsedMB: Maximum memory used.\nMinMemoryUsedMB: Minimum memory used.\nAnalyze Lambda latency (duration) over time:\nfilter @type = \u0026#34;REPORT\u0026#34; | stats avg(@duration), max(@duration), min(@duration) by bin(5m) Generate queries using the prompt Enter your desired query in the Prompt field. Click Generate new query to create the query, then click Run query to execute it. Cold start rate as a percentage of total Lambda invocations "},{"uri":"https://baobui166.github.io/My-Workshop/4-tracingxray/","title":"X-Ray","tags":[],"description":"","content":"In modern microservices or serverless architectures, requests typically travel across multiple components and services. It\u0026rsquo;s difficult to pinpoint \u0026ldquo;which request is slow?\u0026rdquo;, \u0026ldquo;where\u0026rsquo;s the bottleneck?\u0026rdquo;, or \u0026ldquo;where did the error occur?\u0026rdquo; using logs alone.\nAWS X-Ray is a powerful tracing tool that allows you to: Track the full lifecycle of a request across multiple AWS services. Visualize the execution flow and timing with a service map. Identify performance bottlenecks, failures, and latency issues. Debug production issues without digging through logs manually. How to Configure \u0026amp; Use AWS X-Ray 1. Enable X-Ray for Lambda Go to AWS Console → Lambda Choose your desired Lambda function In Monitoring and operations tools, enable Lambda service traces 2. Enable X-Ray for API Gateway Already configured in the Logging \u0026amp; Tracing setup step (see section 3) 3. View Service Map Navigate to Lambda → select the function Click Monitor tab Click View X-Ray Traces 4. Trace Individual Requests Go to the Traces tab Select any trace to view detailed flow: Trace Flow: Shows flow from Client → API Gateway → Lambda Function POST request to UserAPI/Create, Lambda processes and returns 201 Shows timing (66ms) and each component involved Segments Timeline: UserAPI/Create (API Gateway Stage): Received POST, took ~48ms Lambda Invoke: Called create_user function, took ~44ms Lambda Execution: Actual logic took ~20ms + 19ms overhead Total response time: ~66ms, status code 201 (success) Trace with Errors "},{"uri":"https://baobui166.github.io/My-Workshop/3-observability/3.2-cloudwatch/3.2.5-createdashboard/","title":"Create Dashboard","tags":[],"description":"","content":"In modern serverless environments where distributed applications are built, monitoring, tracking, and diagnosing issues are critically important. To avoid getting \u0026ldquo;lost\u0026rdquo; in thousands of log lines, Amazon CloudWatch Dashboard provides an intuitive visual interface.\nObjectives\nMonitor system status in real-time. Quickly detect performance issues or errors. Understand user behavior and API access frequency. Make data-driven decisions, not based on assumptions. The dashboard works like a miniature system map, composed of various charts and metrics, providing both a high-level and in-depth view.\nSteps to Implement 1. Create a new Dashboard Go to CloudWatch Console Select Dashboards → click Create dashboard Name your dashboard (e.g., MonitoringAPI) Choose the widget type to display: Line, Number, Bar, or Text 2. Add API Gateway Monitoring Chart Widget Type: Line Metric: Select API Gateway → By ApiName Choose the following metrics: Latency, 4XXError, 5XXError Statistic: Average Period: 1 Minute 3. Add Lambda Monitoring Chart Widget Type: Line or Number Metric: Service: Lambda Metrics: Duration, Invocations, Errors, Throttles Filter by individual function (by ARN or name) 4. Add DynamoDB Monitoring Chart Widget Type: Line or Stacked Area Metric: Service: DynamoDB Metrics: ConsumedReadCapacityUnits, ConsumedWriteCapacityUnits, ThrottledRequests Filter by each table (table name) 5. Organize the Dashboard Drag and drop widgets to arrange them neatly Use clear names for each chart: “API Error Rate”, “Lambda Duration”, “DynamoDB Usage”, etc. Apply contrasting colors for readability Save after completing the layout "},{"uri":"https://baobui166.github.io/My-Workshop/5-documentation/","title":"Documentation","tags":[],"description":"","content":"In AWS API Gateway, a Stage represents a specific deployment environment of your API — such as dev, test, or prod. Once a REST API is created and developed, it must be deployed to a stage to be accessible via an endpoint.\nExporting an API from a stage allows you to:\nGenerate an OpenAPI (Swagger) document representing the deployed API structure. Share the API structure with the frontend team, mobile developers, or import into tools like Postman, Swagger UI, Insomnia, etc. Version your API and migrate easily between environments. Steps\nAccess AWS API Gateway Open the API Gateway Console Select the REST API you want to export In the left panel → Choose Stages Click on the specific stage (e.g., dev, prod) View Stage Information When a Stage is selected, you’ll see:\nInvoke URL:\nhttps://{restapi-id}.execute-api.{region}.amazonaws.com/{stage} Options for logging, throttling, caching, etc. → This is the endpoint users can call.\nExport the API’s OpenAPI Definition Return to the main API screen (not inside the Stage) Click the Actions button (top-left corner) → Select Export Choose the format:\nSwagger / OpenAPI 2 OpenAPI 3 Download the file as .json or .yaml\n→ This file can be imported into Postman, Swagger UI, or other API documentation tools.\nImport to Postman Open Postman and click Import in the top-left corner Drag and drop the downloaded file and click Import Now you can start using the imported API immediately "},{"uri":"https://baobui166.github.io/My-Workshop/6-cleanup/","title":"Cleaning up resource","tags":[],"description":"","content":"In this section, we will clean up all AWS resources that were created during the workshop in order to:\nAvoid unwanted charges. Clear the testing environment. Ensure compliance with cloud resource management best practices. Delete Lambda Functions Go to the AWS Console → Lambda Select each function (e.g., create_user, get_user) Click Actions → Delete function Enter the function name to confirm and delete If you have multiple functions, double-check to avoid deleting the wrong ones.\nDelete API Gateway Go to AWS Console → API Gateway Select REST APIs Choose the API you want to delete (e.g., UserAPI) Click Actions → Delete API and confirm After deletion, all associated endpoints will no longer be accessible.\nDelete DynamoDB Tables Go to AWS Console → DynamoDB Click on the Tables tab Select each table (e.g., Users) → Actions → Delete Table Confirm the deletion All data will be permanently lost if no backup exists.\n"},{"uri":"https://baobui166.github.io/My-Workshop/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://baobui166.github.io/My-Workshop/tags/","title":"Tags","tags":[],"description":"","content":""}]